{'step': 1, 'logId': 1, 'inputs': {'logText': '<21>Oct 28 18:00:09 soc-32 ntpdate[172578]: adjust time server 120.25.115.20 offset 0.000752 sec', 'logField': "[{'key': '', 'value': 'Oct 28 18:00:09'}, {'key': '', 'value': 'soc-32'}, {'key': '', 'value': 'ntpdate'}, {'key': '', 'value': '172578'}, {'key': '', 'value': '120.25.115.20'}]", 'python_code': 'import re\nfrom functools import lru_cache\n@lru_cache(maxsize=100)\ndef _compile_regex(pattern: str, flags: int = 0) -> re.Pattern:\n    return re.compile(pattern, flags)\nkey_value_p = r"""\n        (?:                        # 起始分隔符检测\n        (?<=[;,:,=(\\-])|       # 关键修正：添加冒号:和连字符-作为合法分隔符\n        ^)\n        \\s*                        # 允许前置空格\n        (?P<key>                   # 键名规则\n            (?![\\d\\-])             # 不能以数字或连字符开头\n            [\\w\\s.-]+              # 允许字母/数字/空格/点/连字符\n        )\n        \\s*=\\s*                    # 等号两侧允许空格\n        (?P<value>                 # 值部分\n            (?:                   \n                (?!\\s*[,;)=\\-])    # 排除前置分隔符（新增-）\n                [^,;)=\\-]+         # 基础匹配（新增排除-）\n            )+\n        )\n        (?=                        # 截断预查\n            \\s*[,;)=\\-]|           # 分隔符（新增-）\n            \\s*$|                  # 字符串结束\n            (?=\\S+\\s*=)            # 后面紧跟新键（含空格键名）\n        )\n    """\n# 时间：不带年份+带年份\ndate_p = r"\\b[A-Za-z]{3}\\s{1,2}\\d{1,2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\b"\ndate_p_ = r"""\\b([A-Za-z]+ \\d{1,2} \\d{4} \\d{2}:\\d{2}:\\d{2})\\b"""\ndate_p_2 = r"([A-Za-z]{3})\\s+ (\\d{1,2})\\s+(\\d{4})\\s+(\\d{2}):(\\d{2}):(\\d{2})([+-]\\d{2}):(\\d{2})"\ndate_p_3 = r"(\\d{4}-\\d{1,2}-\\d{1,2} \\d{2}:\\d{2}:\\d{2}(?:[+-]\\d{2}:\\d{2})?)"\n# 主机名字\nhostname_p = r"(?<=:\\d{2}) ([a-zA-Z0-9._-]+)*(?=\\s)"\n# 进程ID\npid_p = r"([a-zA-Z0-9_-]+)\\[(\\d+)\\]"\npid_p_2 = r"(\\S+)\\s+\\[(.*?)\\]"\n# 端口号\n# from {ip} port {port}\nip_port_p = r"(\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+port\\s+(\\d+)"\n# ip(port)\nip_port_p_2 = r"(\\d+\\.\\d+\\.\\d+\\.\\d+)(?:\\((\\d+)\\))?"\n# ip:port\nip_port_p_3 = r"(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]):([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"\n# 会话ID\nsession_p = r"session (\\d+)"\n# 函数调用\nfunction_p = r"(?!%%.*)([a-zA-Z0-9_-]+)\\((.*?)\\)"\n# 90-09-10-20\nWebPort_p = r"(\\d{1,3}-\\d{1,3}-\\d{1,3}-\\d{1,3})"\n# XXX/YYYY \nslash_pattern = r"([^,/]+)\\/([^,]+)"\n# user-agent\nuser_agent_p = r"Mozilla/5\\.0\\s*\\([^)]+\\)\\s*(?:AppleWebKit/[\\d\\.]+\\s*\\([^)]+\\)\\s*Chrome/[\\d\\.]+\\s*Safari/[\\d\\.]+|[\\w\\s]+/[\\d\\.]+)"\n# HTTP响应码\nHTTPS_code_p = r"HTTP/S响应码/(\\d+)"\n# attack info\nweb_attack_p = r"WEB攻击~([^~]+)~([^~]*)~([中高低]+)"\nsys_attack_p = r"系统告警~+([^~]*)~+([^~]*)~+([中高低]+)~+(\\d+)"\n# json_str\njson_str_p = r\'\'\'\n    "([^"]+)"            # 键\n    \\s*:\\s*              # 分隔符\n    (                    # 值\n        "(?:\\\\"|[^"])*"  # 字符串（支持转义）\n        |$$.*?$$         # 数组\n        |-?\\d+           # 整数\n        |-?\\d+\\.\\d+      # 浮点数\n        |true|false|null # 布尔/空值\n    )\'\'\'\ntarget_keys = {\'类型\', \'Host\'}\nsegment_p = r"""\n    ^\\s*                    # 开头可能存在的空格\n    ({})                    # 捕获目标键（类型|Host|解析域名）\n    \\s*:\\s*                 # 冒号及两侧空格\n    (.+?)                   # 非贪婪捕获值\n    \\s*$                    # 结尾可能存在的空格\n""".format(\'|\'.join(target_keys))\nfangkuohao_p = r"\\[(\\d+)\\]"\n    \ndef get_concrete_words(text):\n    keywords = ["root","system-logind","systemd","APT","run-parts",]\n    keyword_pattern = re.compile(\n    r\'\\b(\' + \'|\'.join(map(re.escape, keywords)) + r\')\\b\', \n    flags=re.IGNORECASE)\n    key_matches = keyword_pattern.findall(text)\n    results = []\n    for match in key_matches:\n        if match:\n            results.append({\'key\': \'\', \'value\': match})\n    if results:\n        return results\n    else:\n        return []\n\ndef remove_prefix(text):\n    return re.sub(r\'^<.*?>\\s*\', \'\', text)\n\ndef match_key_value(pattern, text):\n    results = []\n    compiled_re = _compile_regex(pattern, re.VERBOSE | re.IGNORECASE)\n    for match in compiled_re.finditer(text):\n        key = match.group("key").strip()\n        value = match.group("value").strip()\n        # 处理引号包裹的值\n        if (value.startswith(\'"\') and value.endswith(\'"\')) or \\\n           (value.startswith("\'") and value.endswith("\'")):\n            value = value[1:-1].replace(\'\\\\"\', \'"\')\n        # 智能截断结尾点号（仅当点号后无其他内容）\n        if value.endswith(\'.\') and not re.search(r\'\\d+\\.\\d+\\.\\d+\', value):\n            value = value[:-1]\n        if key and value:\n            key = re.sub(r\'\\s+\', \' \', key)\n            results.append({\'key\': key, \'value\': value})\n    if results:\n        return results\n    else:\n        return []\n\ndef match_date_year(pattern, text):\n    compile_re = _compile_regex(pattern)\n    matches = compile_re.findall(text)\n    results = []\n    for match in matches:\n        if match:\n            results.append({\'key\': \'\', \'value\': match})\n    if results:\n        return results\n    else:\n        print("未找到匹配的日期时间信息, 类似：Oct 28 17:58:09 OR Jun 24 2016 22:16:51")\n        return []\n    \ndef match_date_with_zone(pattern, text):\n    compile_re = _compile_regex(pattern)\n    match = compile_re.search(text)\n    if match:\n        month = match.group(1)\n        day = match.group(2)\n        year = match.group(3)\n        hour = match.group(4)\n        minute = match.group(5)\n        second = match.group(6)\n        timezone_offset = match.group(7) + match.group(8)\n        date = f\'{month} {day} {year} {hour}:{minute}:{second}{timezone_offset}\'\n        return [{"key": "", "value": date}]\n    else:\n        print("未找到匹配的时区信息, 类似：Nov 5 2021 11:34:18+08:00")\n        return []\n    \ndef match_date_ISO(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.search(text)\n    results = []\n    if match:\n        date = match.group(0)\n        results.append({\'key\': \'\', \'value\': date})\n        return results\n    else:\n        print("未找到匹配的ISO日期时间信息, 类似：2015-12-28 06:16:28")\n        return []  \n    \ndef match_hostname(pattern, text):\n    exclude_keywords = [\n    "Removed","session","adjust","Postponed","for","from","port","closed","user","of","New",]\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    for match in matches:\n        if match and match not in exclude_keywords:\n            value = match if isinstance(match, str) else match\n            if not value.isdigit():\n                results.append({\'key\': \'\', \'value\': value})\n    return results\n\ndef match_pid(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    for match in matches:\n        process_name, pid = match\n        results.append({\'key\': \'\', \'value\': process_name})\n        results.append({\'key\': \'\', \'value\': pid})\n    return results\n    \ndef match_ip_number_1(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.search(text)\n    results = []\n    if match:\n        ip = match.group(1)\n        port = match.group(2)\n        results.append({\'key\': \'\', \'value\': ip})\n        results.append({\'key\': \'\', \'value\': port})\n        return results\n    else:\n        return []\n    \ndef match_ip_number_2(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    for ip, port in matches:\n        if ip and port:\n            results.append({\'key\': \'\', \'value\': ip})\n            results.append({\'key\': \'\', \'value\': port})\n    if results:\n        return results\n    else:\n        return []\n    \ndef match_ip_number_3(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    if matches:\n        for item in matches:\n            ip_port = f"{item[0]}:{item[1]}"\n            results.append({\'key\': \'\', \'value\': ip_port})\n    if results:\n        return results\n    else:\n        return []\n    \ndef match_session_id(pattern, text):\n    compiled_re = _compile_regex(pattern, re.IGNORECASE)\n    matches = compiled_re.findall(text)\n    for match in matches:\n        if match:\n            id = [match.group(1) for match in re.finditer(pattern, text, re.IGNORECASE)]\n            if id:\n                return [{\'key\': \'\', \'value\': id[0]}]\n    else:\n        return []\n\ndef match_function(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.search(text)\n    results = []\n    if match:\n        function_name = match.group(1)\n        bracket_content = match.group(2)\n        results.append({\'key\': \'\', \'value\': function_name})\n        results.append({\'key\': \'\', \'value\': bracket_content})\n        return results\n    else:\n        return []\n\ndef match_WebPort(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.search(text)\n    results = []\n    if match:\n        WebPort = match.group(1)\n        results.append({\'key\': \'\', \'value\': WebPort})\n        return results\n    else:\n        return []\ndef match_slash(pattern, text):\n    keywords = ["URL地址","发生时间","服务器IP","服务器端口","主机名","攻击特征串","触发规则","访问唯一编号",\n        "国家","事件","请求方法","标签","动作","威胁","POST数据","省","HTTP/S响应码",]\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    for match in matches:\n        if match and match[0] in keywords:\n            results.append({\'key\': match[0], \'value\': match[1]})\n    return results\n    \ndef match_user_agent(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.findall(text)\n    if match:\n        if len(match) == 1:\n            value = match[0]\n            return {\'key\': \'客户端环境\', \'value\': value}\n    else:\n        # 尝试匹配旧格式的User-Agent\n        p = r"Mozilla/5\\.0\\s*\\[.*?\\]\\s*\\([^)]*\\)"\n        match = re.findall(p, text)\n        if match:\n            if len(match) == 1:\n                value = match[0]\n                return {\'key\': \'客户端环境\', \'value\': value}\n    return []\n\ndef match_HTTPS_code(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    match = compiled_re.search(text)\n    if match:    \n        value = match.group(1)   \n        return {\'key\': \'HTTP/S响应码\', \'value\': value}\n    else:\n        return []\n\ndef slash_filter(results, custom_env_p, https_p, log_text):\n    custom_env_item = match_user_agent(custom_env_p, log_text)\n    https_item = match_HTTPS_code(https_p, log_text)\n    new_results = []\n    for item in results:\n        if custom_env_item and item[\'key\'] == custom_env_item[\'key\']:\n            print("替换UserAgent")\n            item = custom_env_item\n        if https_item and item[\'key\'] == \'HTTP\':\n            print("替换 HTTPS 响应码")\n            item = https_item\n        new_results.append(item)\n    return new_results\n\ndef match_mail(text):\n    compiled_re = _compile_regex(r\'"(?:\\\\"|[^"])*"|[^,]+\')\n    fields = compiled_re.findall(text)\n    cleaned_fields = []\n    for field in fields:\n        cleaned = field.strip(\'"\').replace(\'\\\\"\', \'"\')\n        cleaned_fields.append(cleaned)\n    results = []\n    email_pattern = re.compile(r\'^[\\w.-]+@[\\w.-]+\\.\\w+$\')  # 邮箱匹配规则\n    mail_keywords = re.compile(r\'mail\') # 只有小写\n    for field in cleaned_fields:\n        if mail_keywords.search(field) or email_pattern.fullmatch(field):\n            results.append({"key": "", "value":field})\n    return results\n\ndef match_web_attack(pattern, text):\n    compiled_re = _compile_regex(pattern)\n    matches = compiled_re.findall(text)\n    results = []\n    if matches:\n        results.append({\'key\': \'\', \'value\': \'WEB攻击\'})\n    for attack_type, extra_info, severity in matches:\n        results.append({\'key\': \'\', \'value\': attack_type})\n        results.append({\'key\': \'\', \'value\': severity})\n    if results:\n        return results\n    else:   \n        return [] \n\ndef match_sys_attack(pattern, text):\n    matches = re.findall(pattern, text)\n    results = []\n    if matches:\n        results.append({\'key\': \'\', \'value\': \'系统告警\'})\n    for _, _, severity, num in matches:\n        results.append({\'key\': \'\', \'value\': severity})\n        results.append({\'key\': \'\', \'value\': num})\n    if results:\n        return results\n    else:   \n        return [] \n\ndef match_json_str(pattern, text):\n    import json\n    try:\n        json_str = re.compile(r\'\\{.*\\}\', re.DOTALL).search(text)\n    except:\n        return []    \n    if not json_str: return []\n    compiled_re = _compile_regex(pattern, re.VERBOSE)\n    matches = compiled_re.findall(json_str.group())\n    results = []\n    for key, value in matches:\n        try:\n            parsed_value = json.loads(value)\n        except:\n            parsed_value = value\n        results.append({\'key\': key, \'value\': parsed_value})\n    if results:\n        return results\n    else:\n        return [] \n\ndef match_segment(pattern, text):\n    result = []\n    segments = text.split(\'~\')\n    for seg in segments:\n        compiled_re = _compile_regex(pattern, re.VERBOSE)\n        match = compiled_re.search(seg)\n        if match:\n            key, value = match.groups()\n            result.append({\'key\': key, \'value\': value.strip()})\n    if result:\n        return result\n    else:\n        return []   \n    \ndef match_fangkuohao(pattern, text):\n    compiled_re = _compile_regex(pattern, re.VERBOSE)\n    match = compiled_re.findall(text)\n    if match:\n        v = match.group(1)\n        return [{\'key\': \'\', \'value\': v}]\n    else:\n        return []\n    \ndef get_all_datetimes(log_text):\n    res1 = match_date_year(date_p, log_text)\n    res1_ = match_date_year(date_p_, log_text)\n    res2 = match_date_with_zone(date_p_2, log_text)\n    res3 = match_date_ISO(date_p_3, log_text)\n    res = res1 + res1_+ res2 + res3\n    return res\n\ndef get_all_ip_ports(log_text):\n    res1 = match_ip_number_1(ip_port_p, log_text)\n    res2 = match_ip_number_2(ip_port_p_2, log_text)     \n    res3 = match_ip_number_3(ip_port_p_3, log_text)\n    res = res1 + res2 + res3\n    return res\n\ndef get_components(keyword, log_text):\n    # 定义关键字与对应函数及参数的映射关系\n    component_map = {\n        \'key_value\': (match_key_value, [key_value_p]),\n        \'hostname\': (match_hostname, [hostname_p]),\n        \'date\': (get_all_datetimes, []),\n        \'pid\': [(match_pid, [pid_p]), (match_pid, [pid_p_2])],  # 多模式匹配\n        \'ip_port\': (get_all_ip_ports, []),\n        \'session\': (match_session_id, [session_p]),\n        \'slash\': (match_slash, [slash_pattern]),\n        \'slash_filtered\': (lambda txt: slash_filter(match_slash(slash_pattern, txt), user_agent_p, HTTPS_code_p, txt), []),\n        \'webport\': (match_WebPort, [WebPort_p]),\n        \'web_attack\': (match_web_attack, [web_attack_p]),\n        \'sys_attack\': (match_sys_attack, [sys_attack_p]),\n        \'json_str\': (match_json_str, [json_str_p]),\n        \'email\': (match_mail, []),\n        \'function\': (match_function, [function_p]),\n        \'segment\': (match_segment, [segment_p]),\n        \'keywords\': (get_concrete_words, []),\n        \'fangkuohao\': (match_fangkuohao, [fangkuohao_p]),\n       # f\'{new_key}\': (f\'match_{new_key}\', [f\'{new_pattern}\'])\n    }\n    result = []\n    for key in keyword:\n        if key in component_map:\n            handlers = component_map[key]\n            if not isinstance(handlers, list):\n                handlers = [handlers]\n            for handler in handlers:\n                func, args = handler\n                call_args = args + [log_text] if args else [log_text]\n                result.extend(func(*call_args))\n    return result\n\n# 函数调用例子\nif __name__ == \'__main__\':\n    keywords = [\'hostname\', \'pid\', \'ip_port\', \'date\', \'key_value\', \'function\', \'webport\', \'web_attack\', \'json_str\', \'email\', \'keywords\', \'fangkuohao\']\n    l = "<128>May 16 14:54:09 2024 dbapp APT~30~1~2024-05-16 14:54:09~10.50.134.18:47013~1.1.1.1:53~远程控制~漏洞利用攻击事件~类型:    C&C~高~2405161454090000256~~请求DNS服务器 [1.1.1.1] 解析域名: oast.pro~~~0~4~2~60:db:15:73:46:01~00:00:5e:00:01:0a~0~Host: oast.pro~~~~成功~12~1~630~212002"\n    res = get_components(keywords, l)', 'output_file': 'D:/Competition_Xihu/Resources/LogParserX/src/LogParserX/output/gen/output_1.py'}, 'outputs': '```python\nimport re\nfrom functools import lru_cache\n\n@lru_cache(maxsize=100)\ndef _compile_regex(pattern: str, flags: int = 0) -> re.Pattern:\n    return re.compile(pattern, flags)\n\nkey_value_p = r"""\n    (?:                        # 起始分隔符检测\n    (?<=[;:,=(\\-])|       # 关键修正：添加冒号:和连字符-作为合法分隔符\n    ^)\n    \\s*                        # 允许前置空格\n    (?P<key>                   # 键名规则\n        (?![\\d\\-])             # 不能以数字或连字符开头\n        [\\w\\s.-]+              # 允许字母/数字/空格/点/连字符\n    )\n    \\s*=\\s*                    # 等号两侧允许空格\n    (?P<value>                 # 值部分\n        (?:                   \n            (?!\\s*[,;)=\\-])    # 排除前置分隔符（新增-）\n            [^,;)=\\-]+         # 基础匹配（新增排除-）\n        )+\n    )\n    (?=                        # 截断预查\n        \\s*[,;)=\\-]|           # 分隔符（新增-）\n        \\s*$|                  # 字符串结束\n        (?=\\S+\\s*=)            # 后面紧跟新键（含空格键名）\n    )\n"""\n\ndate_p = r"\\b[A-Za-z]{3}\\s{1,2}\\d{1,2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\b"\ndate_p_ = r"""\\b([A-Za-z]+ \\d{1,2} \\d{4} \\d{2}:\\d{2}:\\d{2})\\b"""\ndate_p_2 = r"([A-Za-z]{3})\\s+ (\\d{1,2})\\s+(\\d{4})\\s+(\\d{2}):(\\d{2}):(\\d{2})([+-]\\d{2}):(\\d{2})"\ndate_p_3 = r"(\\d{4}-\\d{1,2}-\\d{1,2} \\d{2}:\\d{2}:\\d{2}(?:[+-]\\d{2}:\\d{2})?)"\n\nhostname_p = r"(?<=:\\d{2}) ([a-zA-Z0-9._-]+)*(?=\\s)"\n\npid_p = r"([a-zA-Z0-9_-]+)\\[(\\d+)\\]"\npid_p_2 = r"(\\S+)\\s+\\[(.*?)\\]"\n\nip_port_p = r"(\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+port\\s+(\\d+)"\nip_port_p_2 = r"(\\d+\\.\\d+\\.\\d+\\.\\d+)(?:\\((\\d+)\\))?"\nip_port_p_3 = r"(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]):([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"\n\nsession_p = r"session (\\d+)"\n\nfunction_p = r"(?!%%.*)([a-zA-Z0-9_-]+)\\((.*?)\\)"\n\nWebPort_p = r"(\\d{1,3}-\\d{1,3}-\\d{1,3}-\\d{1,3})"\n\nslash_pattern = r"([^,/]+)\\/([^,]+)"\n\nuser_agent_p = r"Mozilla/5\\.0\\s*\\([^)]+\\)\\s*(?:AppleWebKit/[\\d\\.]+\\s*\\([^)]+\\)\\s*Chrome/[\\d\\.]+\\s*Safari/[\\d\\.]+|[\\w\\s]+/[\\d\\.]+)"\n\nHTTPS_code_p = r"HTTP/S响应码/(\\d+)"\n\nweb'}
