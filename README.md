# LogParserX
A well-performance log parser model for rules generation and parsing task focusing on untagged log information. Specifically for 2025th West Lake Digitalsecurity Conference.

----

### Model

- Qwen-2.5-72B-Instruct (about 148GB): https://huggingface.co/Qwen/Qwen2.5-72B-Instruct/tree/main

- Qwen-2.5-7B-Instruct (about 16GB): https://huggingface.co/Qwen/Qwen2.5-7B-Instruct/tree/main

(1) A little try: deployment for Qwen-2.5-7B for testing

For some easy testing, but actually you should interact through API Key.

(2) API Key Link: 

Official：https://help.aliyun.com/zh/model-studio/billing-for-model-studio

WCode：https://wcode.net/qwen-llm-api (Mine)

### HandBook

#### 1. Preparation
Install docker and conda environment:
```shell
conda create -n logX python=3.12
conda activate logX
# logX environment
pip install -r requirements.txt
```
Install crewai:
```shell
pip install crewai
pip install crewai[tools]
# check crewai version
crewai --version
# 0.100.1 / 0.101.9
```
#### 2. Introduction
A. Manual Mode

For manual regex pattern lib, `faster_tool.py` is re.compile version and `tool.py` is the original version.
And it provides Three Evaluation Modes:
`coverage`(`testing_regex.py`), `match`(`official_testing.py`), `combination`(`new_eval.py`)

For coverage mode, the coverage reprents the percentage of the original logField can be covered by the generated logField.
For match mode, the match represents 40% * one_match_rate + 60% * perfect_match_rate (completely match).
For combination mode, the combination represents 40% * one_match_rate + 60% * perfect_match_rate(coverage = 100%).
```shell
python testing_regex.py # log
python official_testing.py # record
python new_eval.py # new_eval
```

B. LogParserX

Use crewai and qwen-llm-api to generate regex pattern lib instead of manual mode.
Main python files include:
- Run Framework: `MergeRegexController.py`
- Data Generation: `DataGeneration.py`, `ClassDivision.py`
- Testing Unit: `RegexChecker.py`, `Executor.py`
- Knowledge Base: `faster_tool.py`, `pattern.py`

Final Result: `/output/opt/*.py`

Immediate Result: `/output/gen/patterns/*.md`, `/output/gen/reports/*.md`, `/output/gen/codes/*.py`, `/output/test/*.py`

LogParserX output structure:
```shell
LogParserX
├── output
│   ├── gen
│   │   ├── codes
│   │   │   ├── output_0.py
│   │   │   ├── output_1.py
|   │   ├── patterns
|   │   │   ├── patterns_0.md
|   │   │   ├── patterns_1.md
|   │   ├── reports
|   │   │   ├── report_0.md
|   │   │   ├── report_1.md
|   ├── opt
│   │   ├── opt_0.py
│   │   ├── opt_1.py
|   ├── test
|   │   ├── test_0.py
│   │   ├── test_1.py
```
**Tips**:
- `gen/codes/output_*.py`: initial codes generated by `code_generator`. They are markdown format python codes.
- `gen/patterns/patterns_*.md`: regex patterns generated by `pattern_checker`. They are markdown format regex patterns.
- `gen/reports/report_*.md`: regex&codes in reports generated by `code_validator`. They are markdown format regex reports.
- `opt/opt_*.py`: optimized codes generated by `code_validator`. They are python codes.
- `test/test_*.py`: test codes fitten by `RegexChecker.py`. They are python codes.

#### 3. Usage
For launch `LogParserX`, you can use the following command:
```shell
python MergeRegexController.py
```
Then it will generate the codes and patterns in `gen/codes/output_*.py`, `gen/patterns/patterns_*.md` and `gen/reports/report_*.md` respectively. 

After that, you can use the following command to generate testing codes for `class_*.json`:
```shell
python RegexChecker.py
```
Then it will generate optimized codes in `opt/opt_*.py` the testing codes in `test/test_*.py`.
And it will calculate the match rate between the testing codes and logs in `class_*.json`.
If the match rate is less than 1, it will calculate the coverage of generated logField and original logField.



